# Bud Cheat Sheet #

## Skeleton of a Bud Module ##

    #!ruby
    require 'rubygems'
    require 'bud'

    module YourModule
      include BudModule
  
      state {
        ...
      }
  
      def bootstrap
        ...
      end
  
      declare 
      def SomeBudStmts
         ...
      end

      declare
      def MoreBudStmts
        ...
      end
    end

## Collection Types ##

### table ###
contents persist in memory until deleted.<br>
default attributes: `[:key] => [:val]`

    table :keyvalue
    table :composite, [:keyfield1, :keyfield2] => [:values]
    table :dupsIgnored, [:field1, field2]

### scratch ###
contents are emptied at the beginning of each timestep
default attributes: `[:key] => [:val]`

    scratch :stats

### interface ###
scratch collections used as module interfaces

    interface input, :request
    interface output, :response

### channel ###
communication channel manifested as a scratch collection.  <br>
address attribute prefixed with `@`.  <br>
default attributes: `[:@address, :val] => []`

    channel :msgs      
    channel :req_chan, [:@address, :cartnum, :storenum] => [:command, :params]

Only async merge (`<~`) allowed for channels on the left of Bud statements.

### periodic ###
system timer manifested as a scratch collection.  argument in seconds.
attributes: `[:ident] => [:time]`

    periodic :timer, 1
    
### stdio ###
    stdio
    

### serializer ###

### file_reader ###

### tctable ###

### zktable ###
  
## Bloom Operators ##

### merges ###

* `left <= right`  merge `right` into `left` *now* (**instantaneous**)
* `left <+ right`  merge `right` into `left` at start of *next* timestep (**deferred**)
* `left <~ right`  merge `right` into `left` *asynchronously* (**async**)

### insert ###

* `left << ['this', 
            {:bloom => true, :ruby => true}, 
            'works', 12]` (**instantaneous**)

### delete ###
* `left <- right`  (**deferred**)

For remote/async delete, merge a request through an async channel:

* `left <- (del_chan <~ right);`   (**async**)

## Collection Methods ##
Common Ruby Enumerable methods, used on a BudCollection `bc`:

* `bc.map`: *useful for relational select/project*
* `bc.flat_map`: *flexible unnesting of attributes*
* `bc.reduce`, `bc.inject`: *custom accumulation/aggregations*
* `bc.empty?`
* `bc.include?`
* `bc.keys`, `bc.values`, `bc.inspectables`

SQL-style grouping/aggregation (and then some):

* `bc.group([:col1, :col2], min(:col3))`.  *akin to GROUP BY*
  * exemplary aggs: `min`, `max`, `choose`
  * summary aggs: `sum`, `avg`, `count`
  * structural aggs: `accum`
* `bc.argmax([:col1], :col2)` *finds the bc tuple per col1 having max col2*
* `bc.argmin([:col1], :col2)`

### Relational operators over Bud Collections: ###

* `join([:t1, :t2], [t1.col1, t2.col2])`
* `natjoin`
* `leftjoin`
* `outerjoin`

### Relational Aggregates: ###

* Exemplary aggs: `min`, `max`, `choose`
* Summary aggs: `count`, `sum`, `avg`
* Structural aggs: `accum`

## Interacting with Bud from Ruby ##
* `run`
* `run_bg`
* `sync_do`
* `async_do`
* `BudCollection.dump`

## Bud Code Visualizer ##