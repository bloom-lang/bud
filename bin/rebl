#!/usr/bin/env ruby
require 'readline'
require 'rubygems'
require 'bud'
require 'abbrev'

TABLE_TYPES = ["table", "scratch"]
BUILTIN_TABLES = [:stdio, :t_depends, :periodics_tbl, :t_cycle, :localtick,
                  :t_provides, :t_rules, :t_depends_tc, :t_stratum]
HISTFILE = "~/.rebl_history"
MAXHISTSIZE = 100

# set up everything
class ReblClass
  include Bud
  attr_accessor :commands
  
  @@commands = {"tick" => ["@rebl_class_inst.tick", "/tick: 	execute a timestep"],
               "lsrules" =>["puts @rules.inspect", "/lsrules: 	list rules"],
               "rmrule" => ["@rules.delete(Integer(split_line[1]));reinstantiate", "/rmrule x: 	remove rule number x"], 
               "lscollections" => ["puts @rebl_class_inst.tables.keys.find_all{ |tn| not BUILTIN_TABLES.include? tn}.inspect", "/lscollections: 	list collections"],
               "dump" => ['@rebl_class_inst.instance_eval("#{split_line[1]}.dump")', "/dump c: 	dump contents of collection c"],
               "exit" => ["ReblClass::do_exit", "/exit: 	exit rebl"],
               "quit" => ["ReblClass::do_exit", "/quit: 	exit rebl"],
               "help" => ["ReblClass::pretty_help", "/help: 	print this help message"] }

	@@abbrevs = @@commands.keys.abbrev
  @@exit_message = "Rebellion quashed."
   
  def self.commands; @@commands; end
  
  def self.command(c)
    return @@abbrevs[c].nil? ? nil : @@commands[@@abbrevs[c]][0]
  end            
  
  def self.pretty_help
    maxlen = @@commands.keys.sort{|a,b| b.size - a.size}.first.size
    @@commands.values.each do |v|
      puts v[1].gsub( /\t/, " "*(maxlen + 3 - v[1].split(':')[0].size))
    end
  end
  
  def self.do_exit
    puts "\n" + @@exit_message
    exit!
  end
end

def reinstantiate
  # new anonymous subclass
  @rebl_class = Class.new(ReblClass)

  if not @rules.empty?
    @rebl_class.class_eval("bloom :rebl_rules do\n" +
                           @rules.sort.map {|_,r| r}.join("\n") + "\nend")
  end

  if not @state.empty?
    @rebl_class.class_eval("state do\n" + @state.values.join("\n") + "\nend")
  end

  # instantiate it
  @old_inst = @rebl_class_inst
  @rebl_class_inst = @rebl_class.new

  # copy the tables over
  if @old_inst
    @rebl_class_inst.tables.merge!(@old_inst.tables.reject do |k,v|
                                     BUILTIN_TABLES.include? k
                                   end)
  end
end

def setup_history
  # permament history; code lifted from irb
  begin
    histfile = File::expand_path(HISTFILE)
    if File::exists?(histfile)
      lines = IO::readlines(histfile).collect { |line| line.chomp }
      Readline::HISTORY.push(*lines)
    end
    Kernel::at_exit do
      lines = Readline::HISTORY.to_a.reverse.uniq.reverse
      lines = lines[-MAXHISTSIZE, MAXHISTSIZE] if lines.nitems > MAXHISTSIZE
      File::open(histfile, File::WRONLY|File::CREAT|File::TRUNC) { |io| io.puts lines.join("\n") }
    end
  rescue Exception
    puts "Error when configuring permanent history: #{$!}"
  end
end

# main
@rules = {}
@ruleid = 0
@state = {}
@stateid = 0
@new_table = nil
reinstantiate
setup_history

comp = proc { |s| ReblClass::commands.keys.map{|c| "/"+c}.grep( /^#{Regexp.escape(s)}/ ) }

Readline.completion_append_character = ' '
Readline.completion_proc = comp

loop do
  begin
    line = Readline::readline('rebl> ')
		ReblClass::do_exit if line.nil?
		line = line.lstrip.rstrip
    Readline::HISTORY.push(line)
    split_line = line.split(" ")

    # command
    if line[0..0] == "/" then
      split_line[0].slice! 0
      if ReblClass::command split_line[0]
        eval ReblClass::command split_line[0]
      else
        puts "invalid command or ambiguous command prefix"
      end
      next
    end

    # collection
    if TABLE_TYPES.include? split_line[0]
      @state[@stateid += 1] = line
      begin
        reinstantiate
      rescue Exception
        @state.delete(@stateid)
        raise
      end
    else # assume it's a rule
      @rules[@ruleid += 1] = line
      begin
        reinstantiate
      rescue Exception
        @rules.delete(@ruleid)
        raise
      end
    end
    next

  rescue Interrupt
    abort(ReblClass::do_exit)
  rescue Exception
    puts "exception: #{$!}"
  end
end
