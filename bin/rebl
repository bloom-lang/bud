#!/usr/bin/env ruby
require 'readline'
require 'rubygems'
require 'bud'
require 'abbrev'

BUILTIN_TABLES = [:stdio, :t_depends, :periodics_tbl, :t_cycle, :localtick,
                  :t_provides, :t_rules, :t_depends_tc, :t_stratum]
TABLE_TYPES = ["table", "scratch", "channel"]

# The class that rebl adds user-specified rules and declarations to.
class ReblClass
  include Bud
  attr_accessor:port, :ip
end


# Static class that contains constants and functions for the rebl shell.
class ReblShell
  @@histfile = File::expand_path("~/.rebl_history")
  @@maxhistsize = 100
  @@escape_char = '/'
  @@commands =
    {"tick" => [lambda {|lib,argv| lib.tick([Integer(argv[1]), 1].max)},
                "tick [x]:\texecutes x (or 1) timesteps"],

    "lsrules" => [lambda {|lib,_| lib.rules.each {|k,v| puts "#{k}: "+v}},
                  "lsrules:\tlist rules"],

    "rmrule" => [lambda {|lib,argv| lib.del_rule(Integer(argv[1]))},
                 "rmrule x:\tremove rule number x"],

    "lscollections" => [lambda {|lib,_| lib.state.each {|k,v| puts "#{k}: "+v}},
                        "lscollections:\tlist collections"],

    "dump" => [lambda {|lib,argv| lib.dump(argv[1])},
               "dump c:\tdump contents of collection c"],

    "exit" => [lambda {|_,_| ReblShell::do_exit}, "exit:\texit rebl"],

    "quit" => [lambda {|_,_| ReblShell::do_exit}, "quit:\texit rebl"],

    "help" => [lambda {|_,_| ReblShell::pretty_help},
               "help:\tprint this help message"]}
  @@abbrevs = @@commands.keys.abbrev
  @@exit_message = "Rebellion quashed."

  def self.escape_char; @@escape_char; end
  def self.commands; @@commands; end

  def self.setup_history
    # permanent history; code lifted from irb
    begin
      if File::exists?(@@histfile)
        lines = IO::readlines(@@histfile).collect { |line| line.chomp }
        Readline::HISTORY.push(*lines)
      end
    rescue Exception
      puts "Error when configuring permanent history: #{$!}"
    end
  end

  def self.command(c)
    return @@abbrevs[c].nil? ? nil : @@commands[@@abbrevs[c]][0]
  end

  def self.pretty_help
    puts "rebl commands are prefixed by '#{@@escape_char}'"
    puts "other input is interpreted as Bloom code."
    puts
    puts "rebl commands:"
    maxlen = @@commands.keys.sort{|a,b| b.size - a.size}.first.size
    @@commands.values.each do |v|
      puts @@escape_char +
        v[1].gsub(/\t/, " "*(maxlen + 3 - v[1].split(':')[0].size))
    end
  end

  def self.welcome
    puts "Welcome to rebl, the interactive Bloom terminal."
    puts
    puts "Type: " + @@escape_char + "h for help"
    puts "      " + @@escape_char + "q to quit"
    puts
  end

  def self.do_exit
    begin
      lines = Readline::HISTORY.to_a.reverse.uniq.reverse
      lines = lines[-@@maxhistsize, @@maxhistsize] if lines.nitems>@@maxhistsize
      File::open(@@histfile, File::WRONLY|File::CREAT|File::TRUNC) do |io|
        io.puts lines.join("\n")
      end
    rescue Exception
      puts "Error when saving permanent history: #{$!}"
    end
    @rebl_class_inst.stop_bg(true) if @rebl_class_inst
    puts "\n" + @@exit_message
    exit!
  end
end


# Library of functions used by rebl.  More generally, this can be viewed as a
# way to have a bud class that you can add and remove rules from, and that you
# can step through the execution of.
class LibRebl
  attr_accessor :rules, :state

  def initialize(ip, port)
    @ip = ip
    @port = port
    @rules = {}
    @ruleid = 0
    @state = {}
    @stateid = 0
    @rebl_class = nil
    @rebl_class_inst = nil
    @old_inst = nil
    reinstantiate
  end

  # Ticks the bud instance a specified integer number of times.
  def tick(x)
    x.times {@rebl_class_inst.sync_do}
  end

  # Dumps the contents of a table at the current time.
  def dump(c)
    @rebl_class_inst.instance_eval("#{c}.dump")
  end

  # Declares a new collection.
  def add_collection(c)
    @state[@stateid += 1] = c
    begin
      reinstantiate
    rescue Exception
      @state.delete(@stateid)
      raise
    end
  end

  # Deactivates a rule at the current time; any tuples derived by the rule at
  # a previous time are still available.
  def del_rule(rid)
    @rules.delete(rid)
    reinstantiate
  end

  # Adds a new rule at the current time; only derives tuples based on data that
  # exists at the current or a future time.
  def add_rule(r)
    @rules[@ruleid += 1] = r
    begin
      reinstantiate
    rescue Exception
      @rules.delete(@ruleid)
      raise
    end
  end

  private

  def reinstantiate
    # new anonymous subclass
    @rebl_class = Class.new(ReblClass)

    begin
      if not @rules.empty?
        @rebl_class.class_eval("bloom :rebl_rules do\n" +
                               @rules.sort.map {|_,r| r}.join("\n") + "\nend")
      end
      if not @state.empty?
        @rebl_class.class_eval("state do\n" + @state.values.join("\n") + "\nend")
      end
    rescue
      raise
    end

    @old_inst = @rebl_class_inst
    ip = @old_inst ? @old_inst.ip : (@ip ? @ip : nil)
    port = @old_inst ? @old_inst.port : (@port ? @port : 0)
    @rebl_class_inst = @rebl_class.new(:no_signal_handlers => true, :ip => ip,
                                       :port => port)

    # copy the tables over
    if @old_inst
      @rebl_class_inst.tables.merge!(@old_inst.tables.reject do |k,v|
                                       BUILTIN_TABLES.include? k
                                     end)
      # fix the bud instance pointers from copied tables
      @rebl_class_inst.tables.values.each do |v|
        v.bud_instance = @rebl_class_inst
      end
    end

    # Run lazily in background, shutting down old instance
    begin
      @old_inst.stop_bg(true) if @old_inst
      @rebl_class_inst.run_bg(true)
      puts "Listening on #{@rebl_class_inst.ip_port}" if not @old_inst
    rescue
      # the above two need to be atomic, or we're in trouble
      puts "unrecoverable error, please file a bug: #{$!}"
      abort
    end
  end
end

# main
Signal.trap("INT") {ReblShell::do_exit}
Signal.trap("TRAP") {ReblShell::do_exit}

ipport = ARGV[0] ? ARGV[0].split(":") : []
lib = LibRebl.new(*[(ipport[0] or "localhost"), (ipport[1] or 0)])
ReblShell::setup_history

comp = proc do |s|
  ReblShell::commands.keys.map do |c|
    ReblShell::escape_char+c
  end.grep( /^#{Regexp.escape(s)}/ )
end
Readline.completion_append_character = ' '
Readline.completion_proc = comp

ReblShell::welcome

loop do
  begin
    line = Readline::readline('rebl> ')
    ReblShell::do_exit if line.nil?
    line = line.lstrip.rstrip
    Readline::HISTORY.push(line)
    split_line = line.split(" ")

    if line[0..0] == ReblShell::escape_char then
      # command
      split_line[0].slice! 0
      if ReblShell::command split_line[0]
        ReblShell::command(split_line[0]).call(lib, split_line)
      else
        puts "invalid command or ambiguous command prefix"
      end
    elsif TABLE_TYPES.include? split_line[0]
      # collection
      lib.add_collection(line)
    else
      # rule
      lib.add_rule(line)
    end

  rescue Interrupt
    abort(ReblShell::do_exit)
  rescue Exception
    puts "exception: #{$!}"
  end
end
